<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Some notes on Receivers</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	===============<br>
	== <a href="https://nico.moe/">CyberJunk</a> ==<br>
	===============
	<div style="float: right;">Made with ðŸ˜­</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
			<a href="https://github.com/slk000"><b>Github</b></a>.
			
			<a href="https://lo-li.net"><b>Chinese</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>Some notes on Receivers</h1>
			<b><time>2023.10.20 14:31</time></b>
		       
		           <a href="/tags/golang">GoLang</a>
        	       

			<div>
				<h1 id="review-of-receivers">Review of receivers</h1>
<p>When a value receiver is defined, Go automatically generates a corresponding pointer receiver.</p>
<p>Auto-generating a pointer receiver causes differences in the method sets of pointer types and value types.</p>
<p>For example, take the <code>Len()</code> method below, Go will automatically generate a corresponding pointer receiver version:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">List</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">List</span>) <span style="color:#a6e22e">Len</span>() <span style="color:#66d9ef">int</span> { <span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">l</span>) }
</span></span><span style="display:flex;"><span><span style="color:#75715e">// func (l *List) Len() int { ... }</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">List</span>) <span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">val</span> <span style="color:#66d9ef">int</span>) { <span style="color:#f92672">*</span><span style="color:#a6e22e">l</span> = append(<span style="color:#f92672">*</span><span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">val</span>) }
</span></span></code></pre></div><p>For type <code>List</code>, its method set includes:</p>
<ul>
<li><code>Len() int</code></li>
</ul>
<p>For type <code>*List</code>, the method set includes:</p>
<ul>
<li><code>Len() int</code></li>
<li><code>Append(int)</code></li>
</ul>
<p>This difference affects the use of interfaces:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Container</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Len</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Append</span>(<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">Container</span> = <span style="color:#a6e22e">List</span>{} <span style="color:#75715e">// no</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">Container</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">List</span>{}
</span></span></code></pre></div><p>However, for the type&rsquo;s own pointer and value, there appears to be no difference, both can call the two methods:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">List</span>{}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pl</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">List</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// List only implements `Len`</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Append</span>(<span style="color:#ae81ff">42</span>) <span style="color:#75715e">// how does Go find `Append`?</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// (&amp;l).Append(42)</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Len</span>() <span style="color:#75715e">// gets 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// *List implements `Append` explicitly, `Len` implicitly</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pl</span>.<span style="color:#a6e22e">Append</span>(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pl</span>.<span style="color:#a6e22e">Len</span>() <span style="color:#75715e">// gets 1</span>
</span></span></code></pre></div><p>In the <code>List</code> method set, there is no <code>Append(int)</code>. Go converts the corresponding call to <code>(&amp;l).Append(42)</code> to implement this which is a syntactic sugar.</p>
<p>However, if you cannot get the address of an object of a certain type, this feature does not work. Non-addressable types include <code>map</code> and <code>interface</code> and some other, as shown below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">List</span>{<span style="color:#e6db74">&#34;list1&#34;</span>: <span style="color:#a6e22e">List</span>{}}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;list1&#34;</span>] <span style="color:#75715e">// cannot take the address of m[&#34;list1&#34;] (map index expression of type List)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#a6e22e">List</span>{}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">List</span>) <span style="color:#75715e">// cannot take the address of i.(List)</span>
</span></span></code></pre></div><p>Because the map stores <code>List</code>, you can directly call <code>List.Len()</code>. Since you cannot take the address of a map element, you cannot convert it to call <code>*List.Append()</code>. The same applies to <code>interface</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;list1&#34;</span>].<span style="color:#a6e22e">Len</span>()) <span style="color:#75715e">// ok</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;list1&#34;</span>].<span style="color:#a6e22e">Append</span>(<span style="color:#ae81ff">42</span>) <span style="color:#75715e">// bad, cannot call the pointer method Append on List</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">List</span>).<span style="color:#a6e22e">Len</span>() <span style="color:#75715e">// ok</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">List</span>).<span style="color:#a6e22e">Append</span>() <span style="color:#75715e">// bad, cannot call the pointer method Append on List</span>
</span></span></code></pre></div><h1 id="what-do-auto-generated-pointer-receivers-do">What Do Auto-Generated Pointer Receivers Do</h1>
<p>If the auto-generated pointer receiver&rsquo;s function body is the same as the value receiver, can I modify the object&rsquo;s value through the pointer? No. In fact, the pointer receiver calls the value receiver and passes arguments by value.</p>
<p>When using <code>dlv debug main.go</code> to debug <code>main.(*List).Len</code>, I found that it doesn&rsquo;t stop at this function breakpoint. Reviewing the previous code, <code>pl.Len()</code> may have been converted to <code>(*pl).Len()</code>, which caused it to use the value receiver. Therefore, it is necessary to forcefully use the pointer receiver:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">List</span>{}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pl</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">List</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// List only implements `Len`</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Append</span>(<span style="color:#ae81ff">42</span>) <span style="color:#75715e">// how does Go find `Append`?</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// (&amp;l).Append(42)</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Len</span>() <span style="color:#75715e">// gets 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// *List implements `Append` explicitly, `Len` implicitly</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pl</span>.<span style="color:#a6e22e">Append</span>(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pl</span>.<span style="color:#a6e22e">Len</span>() <span style="color:#75715e">// gets 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Forcefully call `func(l *List) Len()`</span>
</span></span><span style="display:flex;"><span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">List</span>).<span style="color:#a6e22e">Len</span>(<span style="color:#a6e22e">pl</span>) <span style="color:#75715e">// gets 1</span>
</span></span></code></pre></div><p>It is confirmed that <code>main.(*List).Len</code> internally calls <code>main.List.Len</code>.

<figure>
  <img src="http://static.lo-li.net/images/2023/10/2023-10-20_19-44.png" alt="" />
</figure>




<figure>
  <img src="http://static.lo-li.net/images/2023/10/2023-10-20_19-45.png" alt="" />
</figure>


</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/some-notes-on-receivers/">Some notes on Receivers</a></li>
				
				<li><a href="/posts/lock_based_concurrency_control_protocol/">Lock Based Concurrency Control Protocol</a></li>
				
				<li><a href="/posts/through-an-equality-query-on-a-record-what-locks-will-be-added/">Through an Equality Query on a Record What Locks Will Be Added</a></li>
				
				<li><a href="/posts/auto-generated-primary-key-in-mysql/">Auto Generated Primary Key in MySQL</a></li>
				
				<li><a href="/posts/network-programming-model/">Network Programming Model</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2025 <a href="https://nico.moe/"><b>CyberJunk</b></a>.
	<a href="#"><b>#</b></a>.
	</p>
</footer>

</body>
</html>
